"""
Quick visualization utility for comparing model RMSE side by side.

Reads `models/model_metrics.json` (generated by the API cache or
`train/benchmark_models.py`) and produces:
  - A horizontal bar chart of RMSE per model (sorted bestâ†’worst)
  - A delta plot showing how far each model is from the best RMSE

Outputs (by default, next to the models):
  - `model_benchmark.png`
  - `model_benchmark_delta.png`
"""

import json
import os
import sys
from pathlib import Path
from typing import Dict, Tuple

import matplotlib.pyplot as plt
import pandas as pd


PROJECT_ROOT = Path(__file__).resolve().parents[1]
MODELS_DIR = PROJECT_ROOT / "models"
METRICS_PATH = MODELS_DIR / "model_metrics.json"
DEFAULT_OUTPUT = MODELS_DIR / "model_benchmark.png"
DELTA_OUTPUT = MODELS_DIR / "model_benchmark_delta.png"


def load_metrics() -> Dict[str, float]:
    if not METRICS_PATH.exists():
        sys.exit(f"Metric file not found: {METRICS_PATH}")
    with open(METRICS_PATH, "r") as f:
        data = json.load(f)
    if not data:
        sys.exit(f"No metrics found in {METRICS_PATH}")
    return data


def prepare_dataframe(raw: Dict[str, float]) -> pd.DataFrame:
    df = pd.DataFrame(list(raw.items()), columns=["model", "rmse"])
    df["label"] = df["model"].str.replace(".joblib", "", regex=False)
    df = df.sort_values("rmse").reset_index(drop=True)
    best_rmse = df["rmse"].min()
    df["pct_over_best"] = (df["rmse"] / best_rmse - 1.0) * 100
    return df


def plot_rmse(df: pd.DataFrame, output_path: Path) -> Tuple[Path, float]:
    plt.figure(figsize=(10, 6))

    colors = ["#1b9e77"] + ["#7570b3"] * (len(df) - 1)
    bars = plt.barh(df["label"], df["rmse"], color=colors)
    plt.gca().invert_yaxis()  # best at top
    plt.xlabel("RMSE (lower is better)")
    plt.title("Model benchmark")

    for bar, rmse, pct in zip(bars, df["rmse"], df["pct_over_best"]):
        text = f"{rmse:.1f}"
        if pct > 0:
            text += f"  (+{pct:.1f}%)"
        plt.text(bar.get_width() + 5, bar.get_y() + bar.get_height() / 2, text, va="center")

    plt.tight_layout()
    output_path.parent.mkdir(parents=True, exist_ok=True)
    plt.savefig(output_path, dpi=200)
    return output_path, df["rmse"].min()


def plot_delta(df: pd.DataFrame, output_path: Path) -> Path:
    plt.figure(figsize=(10, 6))
    colors = ["#1b9e77"] + ["#e76f51"] * (len(df) - 1)
    bars = plt.barh(df["label"], df["pct_over_best"], color=colors)
    plt.gca().invert_yaxis()
    plt.xlabel("% over best RMSE (lower is better)")
    plt.title("Gap to best model")

    for bar, pct in zip(bars, df["pct_over_best"]):
        plt.text(
            bar.get_width() + 0.5,
            bar.get_y() + bar.get_height() / 2,
            f"+{pct:.1f}%",
            va="center",
        )

    plt.tight_layout()
    output_path.parent.mkdir(parents=True, exist_ok=True)
    plt.savefig(output_path, dpi=200)
    return output_path


def main():
    out = Path(sys.argv[1]) if len(sys.argv) > 1 else DEFAULT_OUTPUT
    raw = load_metrics()
    df = prepare_dataframe(raw)
    output_path, best = plot_rmse(df, out)
    delta_path = plot_delta(df, DELTA_OUTPUT)
    print(f"Saved benchmark plot to {output_path}")
    print(f"Saved delta plot to {delta_path}")
    print(f"Best RMSE: {best:.2f} ({df.iloc[0]['label']})")


if __name__ == "__main__":
    main()
